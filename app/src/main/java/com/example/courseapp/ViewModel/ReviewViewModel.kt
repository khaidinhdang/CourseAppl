package com.example.courseapp.ViewModelimport androidx.lifecycle.ViewModelimport androidx.lifecycle.viewModelScopeimport com.example.courseapp.model.Commentimport com.example.courseapp.model.Ratingimport com.example.courseapp.model.Userimport com.google.firebase.auth.FirebaseAuthimport com.google.firebase.auth.FirebaseUserimport com.google.firebase.database.DataSnapshotimport com.google.firebase.database.DatabaseErrorimport com.google.firebase.database.FirebaseDatabaseimport com.google.firebase.database.ValueEventListenerimport kotlinx.coroutines.flow.MutableStateFlowimport kotlinx.coroutines.flow.StateFlowimport kotlinx.coroutines.launchclass ReviewViewModel : ViewModel() {    private val db = FirebaseDatabase.getInstance()    private val commentsRef = db.getReference("comments")    private val usersRef = db.getReference("user")    private val auth: FirebaseAuth = FirebaseAuth.getInstance()    var currentUser: FirebaseUser? = null    init {        currentUser = auth.currentUser    }    private val _comments = MutableStateFlow<List<Comment>>(emptyList())    val comments: StateFlow<List<Comment>> = _comments    private val _ratings = MutableStateFlow<List<Rating>>(listOf(        Rating(5, 0, 0f),        Rating(4, 0, 0f),        Rating(3, 0, 0f),        Rating(2, 0, 0f),        Rating(1, 0, 0f)    ))    val ratings: StateFlow<List<Rating>> = _ratings    private val _ratingProgress = MutableStateFlow<Float>(0f)    val ratingProgress: StateFlow<Float> = _ratingProgress    fun addComment(comment: Comment, courseId: String) {        viewModelScope.launch {            try {                val newCommentRef = commentsRef.push()                comment.id = newCommentRef.key ?: ""                newCommentRef.setValue(comment)                fetchComments(courseId)                updateRatings(comment.rating)            } catch (e: Exception) {                // Handle the exception            }        }    }    fun updateComment(commentId: String, comment: Comment, courseId: String) {        viewModelScope.launch {            try {                commentsRef.child(commentId).setValue(comment)                fetchComments(courseId)            } catch (e: Exception) {                // Handle the exception            }        }    }    fun deleteComment(commentId: String, courseId: String) {        viewModelScope.launch {            try {                commentsRef.child(commentId).removeValue()                    .addOnSuccessListener {                        fetchComments(courseId)                    }                    .addOnFailureListener {                        // Handle the error                    }            } catch (e: Exception) {                // Handle the exception            }        }    }    fun setCourseId(courseId: String) {        fetchComments(courseId)    }    private fun fetchComments(courseId: String) {        commentsRef.orderByChild("courseId").equalTo(courseId)            .addListenerForSingleValueEvent(object : ValueEventListener {                override fun onDataChange(dataSnapshot: DataSnapshot) {                    val commentsList = mutableListOf<Comment>()                    dataSnapshot.children.forEach { snapshot ->                        val comment = snapshot.getValue(Comment::class.java)                        comment?.let {                            // Fetch user information if available                            val userId = comment.userId                            fetchUser(userId) { user ->                                val commentWithUser = comment.copy(user = user)                                commentsList.add(commentWithUser)                                // Sort comments by timestamp                                _comments.value = commentsList.sortedByDescending { it.timestamp }                            }                        }                    }                }                override fun onCancelled(databaseError: DatabaseError) {                    // Handle the error                }            })    }    private fun fetchUser(userId: String, callback: (User?) -> Unit) {        usersRef.child(userId).addListenerForSingleValueEvent(object : ValueEventListener {            override fun onDataChange(dataSnapshot: DataSnapshot) {                val user = dataSnapshot.getValue(User::class.java)                callback(user)            }            override fun onCancelled(databaseError: DatabaseError) {                callback(null)            }        })    }    private fun updateRatings(newRating: Int) {        val updatedRatings = _ratings.value.map { rating ->            if (rating.score == newRating) {                val newCount = rating.count + 1                rating.copy(                    count = newCount,                    progress = newCount / (_comments.value.size + 1).toFloat()                )            } else {                rating.copy(                    progress = rating.count / (_comments.value.size + 1).toFloat()                )            }        }        _ratings.value = updatedRatings        _ratingProgress.value = updatedRatings[newRating - 1].progress    }}