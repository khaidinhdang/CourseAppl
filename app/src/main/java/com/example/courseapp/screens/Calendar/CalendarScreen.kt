package com.example.courseapp.screens.Calendarimport androidx.compose.animation.AnimatedVisibilityimport androidx.compose.animation.core.tweenimport androidx.compose.animation.fadeOutimport androidx.compose.animation.shrinkVerticallyimport androidx.compose.foundation.backgroundimport androidx.compose.foundation.clickableimport androidx.compose.foundation.layout.*import androidx.compose.foundation.lazy.LazyColumnimport androidx.compose.foundation.lazy.LazyRowimport androidx.compose.foundation.lazy.grid.GridCellsimport androidx.compose.foundation.lazy.grid.LazyVerticalGridimport androidx.compose.foundation.lazy.grid.itemsimport androidx.compose.foundation.lazy.itemsimport androidx.compose.foundation.shape.RoundedCornerShapeimport androidx.compose.material.BackdropScaffoldimport androidx.compose.material.BackdropValueimport androidx.compose.material.ExperimentalMaterialApiimport androidx.compose.material.icons.Iconsimport androidx.compose.material.icons.filled.Addimport androidx.compose.material.icons.filled.Deleteimport androidx.compose.material.icons.filled.Editimport androidx.compose.material.icons.filled.KeyboardArrowDownimport androidx.compose.material.icons.filled.KeyboardArrowUpimport androidx.compose.material.rememberBackdropScaffoldStateimport androidx.compose.material3.*import androidx.compose.runtime.*import androidx.compose.runtime.livedata.observeAsStateimport androidx.compose.ui.Alignmentimport androidx.compose.ui.Modifierimport androidx.compose.ui.draw.clipimport androidx.compose.ui.graphics.Brushimport androidx.compose.ui.graphics.Colorimport androidx.compose.ui.text.font.FontWeightimport androidx.compose.ui.text.style.TextAlignimport androidx.compose.ui.unit.dpimport androidx.compose.ui.unit.spimport androidx.lifecycle.viewmodel.compose.viewModelimport androidx.navigation.NavHostControllerimport com.example.courseapp.ViewModel.CalendarViewModelimport com.example.courseapp.model.Notesimport com.example.courseapp.screens.component.HeaderScreenimport kotlinx.coroutines.delayimport java.time.LocalDateimport java.time.format.DateTimeFormatterimport java.time.format.TextStyleimport java.util.Locale@OptIn(ExperimentalMaterialApi::class)@Composablefun CalendarScreen(navController: NavHostController) {    val calendarViewModel: CalendarViewModel = viewModel()    val notes by calendarViewModel.notes.observeAsState(emptyList())    val gradientColors = listOf(        Color(0xFFFF8450),        Color(0xFFFFAC71),    )    val gradientBrush = Brush.linearGradient(gradientColors)    val scaffoldState = rememberBackdropScaffoldState(BackdropValue.Revealed)    LaunchedEffect(scaffoldState) {        scaffoldState.reveal()    }    var showSheet by remember { mutableStateOf(false) }    var noteToUpdate by remember { mutableStateOf<Notes?>(null) }    if (showSheet || noteToUpdate != null) {        DialogScreen(            note = noteToUpdate,            onDismissed = {                showSheet = false                noteToUpdate = null            },            onSave = { note ->                if (noteToUpdate != null) {                    calendarViewModel.updateNote(note)                } else {                    calendarViewModel.addNote(note)                }                showSheet = false                noteToUpdate = null            }        )    }    BackdropScaffold(        scaffoldState = scaffoldState,        frontLayerScrimColor = Color.Transparent,        appBar = {            Column(Modifier.padding(top = 10.dp, start = 25.dp, end = 25.dp)) {                HeaderScreen()            }            Spacer(modifier = Modifier.padding(bottom = 13.dp))            Column(Modifier.padding(start = 25.dp)) {                CalendarHeader()                CalendarGrid()            }        },        backLayerContent = {            Spacer(modifier = Modifier.height(20.dp))        },        frontLayerBackgroundColor = Color(0xFFFAFBFF),        modifier = Modifier.background(brush = gradientBrush),        frontLayerContent = {            Column(                modifier = Modifier                    .padding(top = 20.dp, start = 25.dp)            ) {                var expanded by remember { mutableStateOf(false) }                Column(                    modifier = Modifier                        .padding(end = 25.dp)                ) {                    Row(                        horizontalArrangement = Arrangement.Center,                        verticalAlignment = Alignment.CenterVertically                    ) {                        Text(                            text = "My Note",                            fontSize = 20.sp,                            fontWeight = FontWeight.Bold,                            textAlign = TextAlign.Start                        )                        Spacer(modifier = Modifier.height(15.dp))                        Column(modifier = Modifier.clickable { expanded = !expanded }) {                            if (!expanded)                                Icon(Icons.Default.KeyboardArrowDown, contentDescription = null)                            else                                Icon(Icons.Default.KeyboardArrowUp, contentDescription = null)                        }                    }                    Spacer(modifier = Modifier.height(16.dp))                    AnimatedVisibility(visible = !expanded) {                        NoteList(                            notes = notes,                            onDeleteNote = { note ->                                calendarViewModel.deleteNote(note.id)                            },                            onUpdateNote = { note ->                                noteToUpdate = note                            }                        )                    }                }            }            Column(                modifier = Modifier                    .fillMaxSize()                    .padding(bottom = 10.dp),                horizontalAlignment = Alignment.End,                verticalArrangement = Arrangement.Bottom            ) {                Column {                    ExtendedFloatingActionButton(                        icon = {                            Icon(                                Icons.Default.Add,                                tint = Color.White,                                contentDescription = null,                            )                        },                        text = {                            Text(                                text = "Add Task",                                color = Color.White,                            )                        },                        onClick = {                            showSheet = true                        },                        modifier = Modifier.padding(horizontal = 12.dp),                        containerColor = Color.Black,                        elevation = FloatingActionButtonDefaults.elevation(defaultElevation = 8.dp),                    )                }            }        }    )}@Composablefun CalendarHeader() {    val currentDate = LocalDate.now()    val dayOfMonth = currentDate.dayOfMonth    val dayOfWeek = currentDate.dayOfWeek.getDisplayName(TextStyle.SHORT, Locale.getDefault())    val monthYear = currentDate.format(DateTimeFormatter.ofPattern("MMM yyyy"))    Row(        horizontalArrangement = Arrangement.Center,        verticalAlignment = Alignment.CenterVertically,    ) {        Text(            text = dayOfMonth.toString(),            fontSize = 48.sp,            fontWeight = FontWeight.ExtraBold,            color = Color(0xFF2A3447)        )        Spacer(modifier = Modifier.padding(end = 10.dp))        Text(            text = "$dayOfWeek\n$monthYear",            fontSize = 16.sp,            fontWeight = FontWeight.Medium,            color = Color(0xFF5C5454)        )    }}@Composablefun CalendarGrid() {    val currentDate = LocalDate.now()    val daysOfWeek = listOf("Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat")    val startDay = currentDate.dayOfMonth    val daysInMonth = currentDate.lengthOfMonth()    val remainingDaysInMonth = daysInMonth - startDay + 1    Column {        LazyRow(            horizontalArrangement = Arrangement.spacedBy(10.dp),        ) {            items(daysInMonth) { day ->                Card(                    Modifier                        .size(70.dp)                        .clip(shape = RoundedCornerShape(25.dp)),                    colors = CardDefaults.cardColors(containerColor = Color.White),                ) {                    Column(                        Modifier.fillMaxSize(),                        horizontalAlignment = Alignment.CenterHorizontally,                        verticalArrangement = Arrangement.Center                    ) {                        Text(                            text = "${day + 1}",                            fontSize = 24.sp,                            fontWeight = FontWeight.Bold,                            color = Color(0xFF2A3447)                        )                        Text(                            text = daysOfWeek[(day + 1) % 7],                            color = Color(0xFF999898)                        )                    }                }            }        }    }}@Composablefun NoteList(    notes: List<Notes>,    onDeleteNote: (Notes) -> Unit,    onUpdateNote: (Notes) -> Unit) {    LazyColumn(verticalArrangement = Arrangement.spacedBy(15.dp)) {        items(notes) { note ->            SwipeToUpdateOrDeleteContainer(                note = note,                onDelete = { onDeleteNote.invoke(note) },                onUpdate = { onUpdateNote.invoke(note) }            ) {                var expanded by remember { mutableStateOf(false) }                NoteItem(note = note, expanded = expanded) {                    expanded = !expanded                }            }        }    }}@Composablefun NoteItem(note: Notes, expanded: Boolean, onToggleExpansion: () -> Unit) {    Card(        shape = RoundedCornerShape(8.dp),        colors = CardDefaults.cardColors(            containerColor = Color.White        ),        modifier = Modifier            .fillMaxSize()            .clickable { onToggleExpansion() }    ) {        Column(            modifier = Modifier                .fillMaxWidth()                .padding(vertical = 16.dp, horizontal = 12.dp)        ) {            Text(                text = note.title,                fontSize = 18.sp,                fontWeight = FontWeight.Medium,                color = Color(0xFF2A3447),                maxLines = 1            )            Spacer(modifier = Modifier.height(6.dp))            if (expanded) {                Text(                    text = note.description,                    fontSize = 14.sp,                    fontWeight = FontWeight.Medium,                    color = Color(0xFFC3C2C2),                )            }        }    }}@OptIn(ExperimentalMaterial3Api::class)@Composablefun SwipeToUpdateOrDeleteContainer(    note: Notes,    onDelete: () -> Unit,    onUpdate: () -> Unit,    animationDuration: Int = 500,    content: @Composable () -> Unit) {    var isRemoved by remember { mutableStateOf(false) }    val state = rememberDismissState(        confirmValueChange = { value ->            when (value) {                DismissValue.DismissedToStart -> {                    isRemoved = true                    true                }                DismissValue.DismissedToEnd -> {                    onUpdate()                    false                }                else -> false            }        }    )    LaunchedEffect(key1 = isRemoved) {        if (isRemoved) {            delay(animationDuration.toLong())            onDelete()        }    }    AnimatedVisibility(        visible = !isRemoved,        exit = shrinkVertically(            animationSpec = tween(durationMillis = animationDuration),            shrinkTowards = Alignment.Top        ) + fadeOut()    ) {        SwipeToDismiss(            state = state,            background = {                UpdateOrDeleteBackground(swipeDismissState = state)            },            dismissContent = { content() },            directions = setOf(DismissDirection.StartToEnd, DismissDirection.EndToStart)        )    }}@OptIn(ExperimentalMaterial3Api::class)@Composablefun UpdateOrDeleteBackground(    swipeDismissState: DismissState) {    val color = when (swipeDismissState.dismissDirection) {        DismissDirection.EndToStart -> Color.Red        DismissDirection.StartToEnd -> Color.Green        else -> Color.Transparent    }    val icon = when (swipeDismissState.dismissDirection) {        DismissDirection.EndToStart -> Icons.Default.Delete        DismissDirection.StartToEnd -> Icons.Default.Edit // Use appropriate icon for update        else -> null    }    Box(        modifier = Modifier            .fillMaxSize()            .background(color)            .padding(16.dp),        contentAlignment = when (swipeDismissState.dismissDirection) {            DismissDirection.EndToStart -> Alignment.CenterEnd            DismissDirection.StartToEnd -> Alignment.CenterStart            else -> Alignment.Center        }    ) {        if (icon != null) {            Icon(                imageVector = icon,                contentDescription = null,                tint = Color.White            )        }    }}